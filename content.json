{"meta":{"title":"流浪的少年","subtitle":null,"description":null,"author":"zhengyang","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-08-05T13:19:16.000Z","updated":"2017-08-20T10:54:23.706Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"2017年大疆嵌入式秋招求职总结","slug":"DJI","date":"2017-11-15T09:21:37.000Z","updated":"2017-11-15T13:25:13.764Z","comments":true,"path":"2017/11/15/DJI/","link":"","permalink":"http://yoursite.com/2017/11/15/DJI/","excerpt":"大疆应该算是自己秋招准备最充分的一家公司了，一路闯入终面，无奈自身实力有限加上临场发挥不太顺利，最终没有拿到offer，在此记录一下自己的大疆求职历程。","text":"大疆应该算是自己秋招准备最充分的一家公司了，一路闯入终面，无奈自身实力有限加上临场发挥不太顺利，最终没有拿到offer，在此记录一下自己的大疆求职历程。2017年大疆的招聘主要分为提前批和秋招2部分，提前批的时候（大概5月份左右），实验室师兄在群里发了招聘链接，但当时认为自己很多书都没有看，就没有投递简历，很可惜错过了在线测评。事实上大疆提前批对于秋招没有任何影响，应该给自己一次试错的机会。大疆秋招的的简历投递时间节点是2017-09-15号截止，我大概是9月10号左右投递的简历，很顺利的就通过了简历筛选，大概2~3天左右的时间就收到了性格测试的链接。这里需要说的是，尽量不要在简历投递截止日期前投递简历，因为大疆今年投递人数飙升，后面根本没有充足的时间安排面试，我怀疑实验室有几个同学就是因为这个原因没有通过简历筛选的。 性格测试题型上都是选择题，要求收到测试链接的48小时内完成，当时40多分钟就完成了测试，感觉时间上绰绰有余。每年网上关于DJI的求职讨论，性格测试是一个避不开的问题，很多大佬都是栽在这一关上。提前批的时候，我们实验室4个人做了评测，其中只有1个人通过了这个测试，筛选率低到恐怖。通过在网上搜集资料，我主要从以下几方面来准备大疆的性格测试 大疆的企业文化大疆一直标榜自己需要“敢于说真话”、“有真知灼见”、“敢打敢拼”的员工，这个和创始人汪涛的影响不无关系，而且大疆作为一家创业型的公司，具有加班多、工程师文化浓厚的特点。这部分内容，需要多看看网上关于汪涛创业的逸事和新闻稿，有助于我们对创始人和公司文化的了解。在性格测试中，有部分题目会直面求职者的内心世界，我举出几项内容仅供参考 当自己和同事有意见分歧的时候，是在会上直接了当的指出问题还是会后找主管或者同事沟通？ 自己大学时候参加竞赛，当时心里状态如何：“我要赢”还是“注重体验参赛的过程“？ 当自己处于繁忙的工作状态时，女朋友突然来信息了，这时你会怎么做：直接回复信息？假装没看到，等忙完了工作再回复？简短回复自己在工作，待会给她打电话？ 大疆的新闻事件DJI无人机现在享誉全球，在高速发展的过程中，也会碰到各种各样的问题，有用户的投诉、竞争对手的诘难、还有政府部门的严格监管，促使公司对自己的产品和服务做出了一系列的调整。我把知乎上主题关于“大疆”的页面刷了个遍，性格测评中碰到了这么一个问题 是否有必要在无人机上加装SIM卡以跟踪用户行为数据？https://zhuanlan.zhihu.com/p/26591612 ，其中牵扯到目前民用无人机市场的利益争夺，而且海外市场销售的时候，用户隐私权所带来的法律问题也值得重视，因此需要慎重对待。 大疆的产品大疆以无人机起家，以影视航拍傲视全球，性格测试中也涉及到求职者对无人机产品的认识，如 是否需要在无人机上安装紧急制动的按钮，当无人机要和直升机碰撞的时候，可以很好的规避此类风险？ 其他剩下的题目，就是考察求职者的逻辑推理能力和知识面了，在此不再赘述。 主观题目这部分题目是在提前批的时候没有的，性格测试结果提交过后几天，邮箱就收到了客观题的测试链接。由于之前有同学已经做过了这部分的题目，所以我提前准备了一下 谈一谈安全距离和车速的关系？ 谈一谈安全距离和车流量的关系？ 介绍一下你最喜欢大疆的哪一款产品，介绍功的同时说出其吸引你的地方？谈一谈你对大疆发展的看法？ 题目要求1个小时内完成，没有摄像头监控，可以从网上查询资料。我在前期准备充分的情况下，手打答案，只是刚刚好完成了题目。个人感觉这部分题目并不是为了筛选求职者，前2个问题大概是看看个人的语言组织和逻辑思维能力，重点应该是第3个问题，意在从广大求职者那里搜集一下意见。世界上有2种伟大的公司，一种是快速的满足用户的需求痛点，还有一种是主动挖掘用户的需求痛点，让用户买单。 面试历程初面2017-09-19 下午三点多先收到大疆面试的短信和邮件，上面写着可以预约面试时间，结果突然又收到一条邮件说晚上20:20~21:00进行一面。整个人一下子紧张起来，赶紧把操作系统中的相关知识梳理了一遍，然后准备自我介绍和简历项目（主要是面试的太少怕准备不足）。晚上七点多就做到实验室的小办公室里把简历、电脑、纸、笔等东西准备好，预备接下来的电话面试。可是一直等到了20:50才接到大疆工程师的电话（来自广东深圳的座机），说今天还有点事情比较忙，问我是否接受再等半小时再进行面试。当时犹豫了一下，本来想推迟面试的，后来还是决定再等等，毕竟面试机会来之不易。于是又等到了21:20左右，大疆工程师准时打来了电话。工程师就说今天的面试分为三部分，首先是3~5分钟的自我介绍（包含背景、项目简介等），然后是他问问题我来回答，然后是我来提问，总时间大概是40分钟左右。 由于提前准备了一下自我介绍，说起来还比较流畅，将自己的专业背景、知识背景（计算机体系结构、操作系统）还有项目概要简单说明了下，因为考虑到大疆工程师正在看自己的简历，所以我也是按照简历上说明的讲述。讲完以后，他开始问我简历上写的东西，比如我写的熟悉操作系统，他就问我熟悉什么操作系统以及熟悉操作系统的哪部分（回答Linux，操作系统中进程线程管理、调度算法、内存管理等），然后谈到我熟悉的是C语言，就问我变量的作用域问题以及变量加入static以后在内存中存储位置有什么变化（从栈中移到了数据段中）。 这之后就开始按照简历一个项目一个项目的过，首先问我所有项目中最拿手的项目，我回答课题做的还不是很完善，HW项目也是一个研究性的课题，就一个xmos的音乐盒子项目比较拿手一点。然后就开始讲项目中的点，比如我碰到的印象比较深刻的点（1、晶振电压问题，2、三种功能分步切换启动的问题）。然后还重点问了HW项目，提到是否用到最新的神经网络算法进行优化处理。我回答这一块是由做算法的同学来进行优化。最后就开始聊对大疆的认识和看法，自己在前期看了大量大疆的新闻和产品视频，因此聊的还比较顺利。 终面几天之后，收到了大疆终面的邮件，心里非常忐忑。因为我有同学今年经历了2轮甚至3轮电话面，而自己一轮就到终面了，也许终面的时候会加大难度。担心也是多余的，只能老老实实看书，2017-09-28 一大早就从南京坐火车赶到上海大疆分部。DJI上海公司位于张江高科地铁站附近，周围分布了ZTE、芯原等一系列公司，还是很有科技氛围的。有室友老马在里面实习，带着我熟悉环境之后就去吃饭了，大概13点在公司前台签到，看着签到表上满页满页的名字，压力非常大，嵌入式这一项今天就有17个名单，而像这样的面试已经持续了四五天之久，竞争很激烈。签到流程搞定之后就在工作间里等着面试，2点多一点被HR叫到名单开始面试。 面试官年龄算是有点偏大的（40岁左右，头都秃了），首先介绍面试的时间是20min，主要问了如下的东西： 用3句话介绍自己的优点 我的项目中涉及音频，然后开始问I2S协议是什么？I2S中左右对齐是干嘛的？这个有点忘记了，后来还是画出来了，最懵逼的是问我I2S协议为什么需要左右对齐？没有回答出来，因为自己用I2S的时候没有用到这么深入。 问我相比别的求职者的优势在哪里？我回答说对体系结构比较了解，结果就悲剧了，给自己埋了坑。问RISC和CISC的区别，以及从程序员的角度看在编程的时候需要注意什么区别？这里没有回答出来，开始往cache方向引，问cache line为什么要这么大？cache中组关联和全关联的区别，简要介绍下二者的区别。 接着问我自己相比别人的技术优势在哪里，心态在这个时候开始有点崩了，不敢随便说，就说用C语言比较熟悉，然后问C语言的代码量？用C语言是否写过什么工具？自己在平时编程的时候碰到问题如何解决的？由于刚结束xmos项目，于是开始往FIFO方面引。总之感觉没有突出自己的特色，自己确实除了工作以外没有用C语言写过其他的东西，给面试官的感觉就是刷题和做项目，并没有一种对技术的热情~~ 最后面试官说目前社会上很多人对大疆有一些负面的评价，你是怎么看待这个问题的？对大疆无人机发展的看法？整场面试下来，感触就是面试官知识面是非常广的，对体系结构和嵌入式编程方面都非常熟悉，问题都是先抛出某个点，我回答出“是什么”以后，再深入挖掘“为什么”。从个人角度来看，自己对知识点的理解不够到位，主要是局限于知识点“是什么”阶段，对于这个技术点的设计哲学确实关注过少，导致面试官问一些宽泛的点不知道着眼点在哪里。还有就是平时自己的技术积累不够到位，代码量和工程经验不足，面试底气不够。 笔试阶段本来面试后觉得没戏了，可是国庆节前收到了笔试的邮件，说我“一路过关斩将，进入了笔试环节，离拿offer只差一步之遥”。当时那个激动啊，起死回生的感觉。笔试时间是国庆收假后的第一个工作日 2017-10-09 19:00，平台是赛码网。题目还算比较常规，分为单选、多选、填空、简答和编程4个环节：单选、多选和填空主要考察的点是Linux使用、操作系统相关概念、RTOS知识点、数据结构和C语言基础 简答题目 说说软件性能优化的思路和方法 DSP和ARM处理器的区别 内核态和用户态通信的方法 有7克、2克砝码各一个，天平一只，如何用这些物品三次将140克的盐分成50、90克各一份 编程题目（不用AC） 用尽可能简短的代码实现二叉树节点的个数统计 用冒泡排序实现链表节点的排序 惜别大疆和我一起面试的室友很早就收到了大疆工程师的电话，而我这边完全没人联系，陆陆续续在大疆交流群看到有同学笔试或者面试未通过，心情一下子又跌入谷底了。大概10月中旬的时候，突然间又收到大疆工程师联系的电话，说现在面试结果提交总部审核，问我签约意愿之类的，当然是满口的答应了。然后是陷入漫长的审核等待……到了10月底的时候，得知审核未通过……心里真是满满的失落，无以言表……","categories":[],"tags":[{"name":"求职","slug":"求职","permalink":"http://yoursite.com/tags/求职/"}]},{"title":"C语言常用库函数实现","slug":"C语言常用库函数实现","date":"2017-09-10T12:36:01.000Z","updated":"2017-11-14T06:40:11.683Z","comments":true,"path":"2017/09/10/C语言常用库函数实现/","link":"","permalink":"http://yoursite.com/2017/09/10/C语言常用库函数实现/","excerpt":"","text":"函数实现中所有的assert都需要添加头文件 assert.h strcmp strcmp(const char str1, const char str2) 函数用来比较字符串，对两个字符串自左至右逐个字符相比较（按照ASCII大小），直到出现不同的字符或遇到 ‘\\0’ 为止。 如果全部字符相等，则认为相等；如果出现不相同的字符，则以出现第一个不相同的字符的比较结果为准。 两字符如果全部都是英文字母，则有一个简单的规律：在英文字典中位置在后面的为“大”，小写字母比大写字母“大”。 数字、小写字母、大写字母的ASCII码值顺序为：0 ~ 9、A ~ Z、a ~ z 依次递增。123456789int strcmp(const char *str1, const char *str2)&#123; for(; *str1 == *str2; str1++, str2++)&#123; if(*str1 == &apos;\\0&apos;)&#123; //此处注意&apos;\\0&apos; 指的是NULL，对应的ASCIII码值为0，作为字符串的结束符 return 0; &#125; &#125; return ( *(unsigned char *)str1 &lt; *(unsigned char *) str2 ? -1 : 1); //使用unsigned char的原因是char的范围-128~127，unsigned char的范围是0~255，如果不使用unsigned char的话，传入ASCII没有问题，但是传入扩展ASCII就会出问题&#125; strcpy12345678910111213141516char *strcpy(const char *dest, const char *src)&#123; assert((dest != NULL) &amp;&amp; (src != NULL)); char *temp = dest; //目的指针需要记录下来，作为指针变量的返回值 while((*dest++ = *src ++) != &apos;\\0&apos;); return temp;&#125;//上述代码中while循环中的部分不是很好理解，可以写为下面的部分char *strcpy(const char *dest, const char *src)&#123; assert((dest != NULL) &amp;&amp; (src != NULL)); char *temp = dest; while(*src != &apos;\\0&apos;)&#123; *dest ++ = *src ++; &#125; return temp;&#125; memcpystrcpy和memcpy主要有以下3方面的区别。 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。12345678910void *memcpy(void *dest, const void *src, size_t n)&#123;//需要特别注意目的指针和源指针的区别 char *pbTo = (char *)dest; char *pbFrom = (char *)src; assert(dest != NULL &amp;&amp; src != NULL); assert(pbTo &gt;= pbFrom + count &amp;&amp; pbFrom &gt;= pbTo + count);//防止出现内存重叠（overlap) while(count --)&#123; *pbTo ++ = *pbFrom ++； &#125; return dest;&#125; memcpy的优化部分在《C专家编程》P151中有体现，主要讲的是根据处理器cache行的容量来使用memcpy填充会极大的提高效率。 memset123456789void *memset(void *buf, int c, size_t count)&#123; const unsigned char uc = c; unsigned char *pbTo = buf; assert(buf != NULL); while(count --)&#123; *pbTo ++ = uc; &#125; return buf;&#125; 注意 此函数中，将int型的数转换成了unsigned char类型的数，即截去了高24位，只保留了低8位。而且将void buf指针类型的值赋给了unsigned char 类型，意味着pbTo所指向的存储位置每个元素按照8位来计算。因此如下的代码1234567891011121314int main()&#123; int a[8] = &#123;1, 2, 4, 4, 5, 6, 7, 8&#125;; int b = 1; memset(a, b, 8*sizeof(int)); int i=0; for(i=0; i&lt;8; i++)&#123; printf(&quot;%d &quot;, a[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125;输出为16843009 16843009 16843009 16843009 16843009 16843009 16843009 16843009 但是我们希望的是，将数组a中所有元素赋值为1, 出现这个问题的原因还是需要归结到上面memset的实现中1234c的二进制 : 00000000000000000000000000000001(32位)c转换为unsigned char 后：00000001（8位）将指针su（unsigned char类型）的每一元素（8位）赋值为00000001，循环4n次。memset()结束后，a数组的每个元素按照int类型读取，读出来的就是1000000010000000100000001，十进制就是16843009。 不过如果是memset(arr, 0, n * sizeof(int)); 的话可以使用，因为32位都是0。 atoi123456789101112131415161718192021int atoi(const char *str)&#123; int sign = 0; int num = 0; assert(str != NULL); while(*str == &apos; &apos;)&#123; str ++; &#125; if(*str == &apos;-&apos;)&#123; sign = 1;//判断数字的正负号 str ++; &#125; while(*str &gt; &apos;0&apos; &amp;&amp; *str &lt; &apos;9&apos;)&#123; num = *str - &apos;0&apos; + num * 10;//进行数值转换的关键代码 str ++; &#125; if(sign == 1)&#123; return -num; &#125; else return num;&#125; itoa123456789101112131415161718192021222324252627282930313233char* itoa(int val,char* buf,unsigned int radix)&#123; char *bufptr; char *firstdig; char temp; unsigned int digval; assert(buf != NULL); bufptr = buf; if (val &lt; 0) &#123; *bufptr++ = &apos;-&apos;; val = (unsigned int)(-(int)val); &#125; firstdig = bufptr; do &#123; digval =(unsigned int) val % radix; val /= radix; if (digval &gt; 9) &#123; *bufptr++ = (char)(digval - 10 + &apos;a&apos;); &#125; else &#123; *bufptr++ = (char)(digval + &apos;0&apos;); &#125; &#125; while(val &gt; 0); *bufptr-- = &apos;\\0&apos;;//设置字符串末尾，并将指针指向最后一个字符 do //反转字符 &#123; temp = *bufptr; *bufptr = *firstdig; *firstdig = temp; --bufptr; ++firstdig; &#125; while(firstdig &lt; bufptr); return buf;&#125; atof123456789101112131415161718192021222324252627282930double atof(const char* str)&#123; double val = 0.0,power = 0.0; int sign = 0; assert(NULL != str); while (*str == &apos; &apos;) &#123; str++; &#125; sign = (*str == &apos;-&apos;)? -1 : 1; if (&apos;-&apos; == *str || &apos;+&apos; == *str) &#123; str++; &#125; while ((*str &gt;= &apos;0&apos;)&amp;&amp;(*str &lt;= &apos;9&apos;)) &#123; val = val* 10.0 + (*str - &apos;0&apos;); str++; &#125; if (&apos;.&apos; == *str) &#123; str++; &#125; power = 1.0; while ((*str &gt;= &apos;0&apos;)&amp;&amp;(*str &lt;= &apos;9&apos;)) &#123; val = val* 10.0 + (*str - &apos;0&apos;); power *= 10; str++; &#125; return sign*val/power;&#125; memove1234567891011121314151617181920212223void* memmove(void* dst,const void* src,size_t count)&#123; char* pbTo = (char*)dst; char* pbFrom = (char*)src; assert(dst != NULL &amp;&amp; src != NULL); if (dst &lt;= src || pbTo &gt;= pbFrom + count)//没有overlap的情况，直接拷贝 &#123; while (count-- &gt; 0) &#123; *pbTo++ = *pbFrom++; &#125; &#125; else &#123; pbTo = pbTo + count -1;//overlap的情况，从高位地址向低位拷贝 pbFrom = pbFrom + count -1; while (count-- &gt; 0) &#123; *pbTo-- = *pbFrom--; &#125; &#125; return dst;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"处理器相关知识概要","slug":"处理器相关知识概要","date":"2017-09-04T14:05:13.000Z","updated":"2017-09-04T14:31:55.198Z","comments":true,"path":"2017/09/04/处理器相关知识概要/","link":"","permalink":"http://yoursite.com/2017/09/04/处理器相关知识概要/","excerpt":"","text":"《计算机组成与设计——软件/硬件接口》 第四章 处理器性能评估标准 指令数 CPI（执行每条指令需要的周期数） 时钟周期的长度 流水线相关单周期还是流水线设计 单周期 一个时钟周期执行一条指令指令的实现机制，时钟周期对所有指令等长，时钟周期由执行时间最长的那条指令决定，使得指令执行的性能不是太好 流水线设计 MIPS的指令集是针对流水线做了优化的 所有的MIPS指令长度都是等长的，简化了取指和译码的过程 MIPS中指令的格式比较少而且指令中源寄存器字段的位置都是相同的 MIPS中的存储器操作数仅出现在存取指令中 所有的操作数在存储器中对齐，实现一次访存就完成请求数据的传输 流水线冒险 结构冒险：处理器硬件不能实现指令的流水线执行，导致指令无法在固定的时钟周期内执行。 数据冒险：无法提供指令执行所需数据导致指令不能在预定的时钟周期内执行的情况。 主要原因：一条指令依赖于更早一条还在流水线中的指令造成的。 解决方法：是采取 前推 或者 旁路 的方法。 控制冒险：也称为 分支冒险，取到的指令并不是所需要的而导致指令不能在预定的时钟周期内执行。 解决方法： 流水线阻塞 分支预测：预测分支结果并立即执行，而不是等分支结果确定以后才开始执行。 CPU执行指令的流水线 取指：从指令存储器读取指令 译码：指令译码的同时读取寄存器（MIPS允许指令译码和读取寄存器） 执行：执行操作或者计算地址 数据存储器访问：从数据存储器中读取操作数 写回：将结果写回寄存器 指令集并行增加流水线并行度的方法 增加流水线的深度以及重叠更多的指令。 复制计算机内部部件的数量，使得每个流水线可以启动多条指令（即多发射）。 静态多发射：编译器静态编译进行的。 动态多发射：指令在执行时由处理器部件动态进行的。 静态多发射处理器 发射包：在一个时钟周期内发射的多条指令的集合。 超长指令字：一类可以同时启动多个操作的指令集，其中操作在单个指令中互相独立，并且一般都有独立的操作码段。 寄存器重命名：在循环展开的时候，编译器引入几个临时的寄存器。目的是消除指令之间一些虚假的数据依赖，这些虚假的数据依赖可能导致潜在的冒险或者妨碍编译器灵活的调度。 动态多发射处理器（超标量） 在最简单的超标量处理器中，指令顺序发射，每个周期处理器决定是发射0条、1条还是多条指令，要达到好的性能依然依赖编译器的调度以达到错过数据依赖的目的。但是不管代码是否经过调度，都是由硬件来保证执行的正确性。而且编译器得到的代码始终正确执行，跟处理器的流水线结构和指令发射速率无关。 动态流水线调度：对指令进行重排序以避免阻塞的硬件支持。 提交单元：位于动态流水线和乱序流水线中的一个单元，用以决定何时将结果送至程序员可见的寄存器和存储器。 功能单元：用来保存操作数和寄存器。 重排序缓冲区（提交单元中的缓冲区，reorder buffer）：动态调度处理器中用来保存执行结果的缓冲区，等到安全时才将其中的结果写回寄存器或存储器。","categories":[{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"http://yoursite.com/categories/计算机体系结构/"}],"tags":[{"name":"处理器","slug":"处理器","permalink":"http://yoursite.com/tags/处理器/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2017-08-23T07:10:23.000Z","updated":"2017-08-23T07:22:58.500Z","comments":true,"path":"2017/08/23/Linux常用命令/","link":"","permalink":"http://yoursite.com/2017/08/23/Linux常用命令/","excerpt":"","text":"注：图片转载自 王爵的技术小黑屋——写代码怎能不会这些Linux命令？","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"死锁","slug":"死锁","date":"2017-08-20T08:42:51.000Z","updated":"2017-11-14T07:16:17.210Z","comments":true,"path":"2017/08/20/死锁/","link":"","permalink":"http://yoursite.com/2017/08/20/死锁/","excerpt":"资源死锁主要是跟资源相关，一般情况下，资源可以是硬件设备（比如磁带、打印机）或者是一组信息（如数据库中一个加锁的记录）。资源分为可抢占和不可抢占： 可抢占式资源：可以从拥有它的进程中抢占而不会产生任何副作用，比如存储器。 不可抢占式资源：指的是在不引起相关计算失败的情况下，无法把它从占有它的进程处抢占过来，比如CD刻录机正在被一个进程抢占的时候，其他的进程如果抢占CD刻录机会导致原始的刻录失败。","text":"资源死锁主要是跟资源相关，一般情况下，资源可以是硬件设备（比如磁带、打印机）或者是一组信息（如数据库中一个加锁的记录）。资源分为可抢占和不可抢占： 可抢占式资源：可以从拥有它的进程中抢占而不会产生任何副作用，比如存储器。 不可抢占式资源：指的是在不引起相关计算失败的情况下，无法把它从占有它的进程处抢占过来，比如CD刻录机正在被一个进程抢占的时候，其他的进程如果抢占CD刻录机会导致原始的刻录失败。 资源的使用情况为： 请求资源 使用资源 释放资源 进程请求和使用资源就会产生一定的问题，比如2个进程A和B，A占有a资源，B占有b资源，如果A请求b资源的同时B也同时请求a资源，且双方都没有释放原有的资源，此时就会产生死锁问题。 死锁概述 如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么此进程集合就是 死锁 的。 资源死锁发生的4个必要条件： 互斥条件。每个资源要么已经分配给一个进程，要么就是可用的。 占有和等待条件。已经得到某个资源的进程可以再请求其他新的资源。 不可抢占条件。已经分配给一个进程的资源不能强制性的被抢占，它只能被占有它的进程显示的释放。 环路等待条件。死锁发生时，系统中一定有两个或者两个以上的进程组成的一条环路，该环路中有的每个进程都在等待着下一个进程所占有的资源。 处理死锁的策略： 忽略该问题。也许如果你忽略它，它也会忽略你。【不闻不顾】 检测死锁并恢复。让死锁发生，检测他们是否发生，一旦发生死锁，才去行动解决问题。【亡羊补牢】 仔细对资源进行分配，动态得到避免死锁。【未雨绸缪】 通过破坏引起死锁的四个必要条件之一，防止死锁的发生。【追本溯源】 处理死锁的几种思路鸵鸟算法 鸵鸟算法：把头埋进沙子中，假装根本没有问题发生。 这里主要讲的是死锁问题在某些情况下是否值得解决？数学家认为程序讲究的是完备性，不管效率之类的问题，必须解决。而工程师首先需要评估死锁发生的频率、系统因各种原因崩溃的发生次数以及死锁的严重性，如果死锁5年发生一次，而其他的硬件故障等导致系统每月崩溃一次，那么工程师是不会以性能损失和可用性的代价去防止死锁。 死锁检测和死锁恢复（1）死锁检测 每种类型一个资源的死锁检测 主要涉及到有向图的深度优先搜索。 每种类型多个资源的死锁检测 （2）死锁恢复 假设检测算法已经检测到系统中产生了死锁问题，接下来就是考虑如何恢复系统的正常运行了。 利用抢占恢复在不通知原进程的情况下，将某一资源从一个进程强行取走给另一个进程使用，接着又送回，这种做法是否可行主要取决于该资源本身的特性。用这种方法恢复通常比较困难或者说不太可能。若选择挂起一个进程，则在很大程度上取决于一个进程拥有比较容易回收的资源。 利用回滚恢复 周期性的备份进程作为检查点（包含存储映像、资源状态、资源分配给了哪些进程），而且新的检查点不会覆盖原有的检查点，一旦检查到进程出现了死锁现象，将进程复位到死锁出现之前的状态。 杀死进程恢复 通过杀死死锁环上的进程，直接破坏死锁环路；杀死死锁环路以外的进程作为牺牲品，从而释放资源；最好杀死可以从头开始运行而不会带来副作用的进程。 死锁预防 死锁避免从本质上是不可能的，因为它需要获知未来的请求，而这些请求是不可知的。 通过破坏死锁环路，我们可以避免死锁： 破坏互斥条件 资源不被一个进程独占，那么死锁是不会发生的。 破坏占有和等待条件 当一个进程获得所需要的全部资源后才开始运行，这样不会产生死锁，但是会造成运行效率低下。 破坏不可抢占条件 破坏环路等待条件 请求其他资源之前释放掉现在占有的资源；对所有资源统一编号，以保证资源请求的有序性，从而不会产生死锁。 其他问题两阶段加锁第一阶段对需要的资源进行加锁，第二阶段完成更新后释放锁。主要在于第一阶段，如果进程请求的部分资源已经被其他进程加锁，那么需要释放现在已经加锁的资源，然后重新开始第一阶段。 通信死锁死锁并不局限于资源死锁，比如通信中客户端和服务器端由请求信号丢失，相互等待对方的信号产生死锁。 活锁 没有出现死锁现象（因为无进程阻塞），但是从现象上看好像死锁发生了，这就是活锁。 指事物1可以使用资源，但它让其他事物先使用资源；事物2可以使用资源，但它也让其他事物先使用资源，于是两者一直谦让，都无法使用资源。 避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。 饥饿一个进程由于优先级等情况一直被延迟执行而导致“饥饿而死”（无限制地推后，尽管它没有被阻塞）。 饥饿可以通过先来先服务资源分配策略来避免，在此情形下，等待最久的进程会是下一个被调度的进程，随着时间的推移，所有进程都会变成最“老”的，因为，最终能够获得资源而完成。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://yoursite.com/tags/OS/"}]},{"title":"Hexo使用","slug":"hexo使用","date":"2017-08-05T14:27:41.000Z","updated":"2017-08-20T09:18:56.931Z","comments":true,"path":"2017/08/05/hexo使用/","link":"","permalink":"http://yoursite.com/2017/08/05/hexo使用/","excerpt":"","text":"今天摆弄了一天Hexo的使用方法，由于自己对建站不是很熟悉，从解析域名到托管网站，以及修改主题模板，都耗费了不少的时间，不过欣喜的是现在网站总算有点模样了。 Hexo安装下载Node.js我是在Windows下安装的Node.js，安装好以后再cmd命令下可以显示如下的效果12345$ C:\\Users\\zy&gt;node -vv8.2.1$ C:\\Users\\zy&gt;npm -v5.3.0 安装Hexo采用npm包管理软件安装hexo会非常慢，搜索了下，建议从淘宝的镜像站点安装，输入如下的命令1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 以后，凡是涉及到npm安装软件，都采用cnpm命令安装，可以极快的提高软件下载安装速度。接下来就是安装hexo了1234567891011121314151617$ cnpm install hexo-cli -g $ cnpm install hexo --save$ hexo -vhexo-cli: 1.0.3os: Windows_NT 10.0.14393 win32 x64http_parser: 2.7.0node: 8.2.1v8: 5.8.283.41uv: 1.13.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57openssl: 1.0.2licu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b 这样就算是完成了hexo的安装。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"计算机存储结构的区别","slug":"计算机体系结构的区别","date":"2017-08-05T12:26:24.000Z","updated":"2017-11-14T08:08:20.077Z","comments":true,"path":"2017/08/05/计算机体系结构的区别/","link":"","permalink":"http://yoursite.com/2017/08/05/计算机体系结构的区别/","excerpt":"哈佛结构哈佛结构是一种将程序指令存储和数据存储分开的存储器结构。中央处理器首先到程序指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。程序指令存储和数据存储分开，可以使指令和数据有不同的数据宽度，如Microchip公司的PIC16芯片的程序指令是14位宽度，而数据是8位宽度。目前使用哈佛结构的中央处理器和微控制器有很多，除了上面提到的Microchip公司的PIC系列芯片，还有摩托罗拉公司的MC68系列、Zilog公司的Z8系列、ATMEL公司的AVR系列和安谋公司的ARM9、ARM10和ARM11，51单片机也属于哈佛结构","text":"哈佛结构哈佛结构是一种将程序指令存储和数据存储分开的存储器结构。中央处理器首先到程序指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。程序指令存储和数据存储分开，可以使指令和数据有不同的数据宽度，如Microchip公司的PIC16芯片的程序指令是14位宽度，而数据是8位宽度。目前使用哈佛结构的中央处理器和微控制器有很多，除了上面提到的Microchip公司的PIC系列芯片，还有摩托罗拉公司的MC68系列、Zilog公司的Z8系列、ATMEL公司的AVR系列和安谋公司的ARM9、ARM10和ARM11，51单片机也属于哈佛结构 冯·诺伊曼结构冯·诺伊曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同，如英特尔公司的8086中央处理器的程序指令和数据都是16位宽。 目前使用冯·诺伊曼结构的中央处理器和微控制器有很多。除了上面提到的英特尔公司的8086，英特尔公司的其他中央处理器、安谋公司的ARM7、MIPS公司的MIPS处理器也采用了冯·诺伊曼结构。 哈佛结构和冯.诺依曼结构都是一种存储器结构。哈佛结构是将指令存储器和数据存储器分开的一种存储器结构；而冯.诺依曼结构将指令存储器和数据存储器合在一起的存储器结构。 嵌入式系统的存储结构MCS-51单片机有着嵌入式处理器经典的体系结构，这种体系结构在当前嵌入式处理器的高端ARM系列上仍然在延续，这就是哈佛结构。相对于大名鼎鼎的冯·诺依曼结构，哈佛结构的知名度显然逊色许多，但在嵌入式应用领域，哈佛结构却拥有着绝对的优势。哈佛结构与冯·诺依曼结构的最大区别在于冯·诺依曼结构的计算机采用代码与数据的统一编址，而哈佛结构是独立编址的，代码空间与数据空间完全分开。 在通用计算机系统中，应用软件的多样性使得计算机要不断地变化所执行的代码的内容，并且频繁地对数据与代码占有的存储器进行重新分配，这种情况下，冯·诺依曼结构占有绝对优势，因为统一编址可以最大限度地利用资源，而哈佛结构的计算机若应用于这种情形下则会对存储器资源产生理论上最大可达50%的浪费，这显然是不合理的。 但是在嵌入式应用中，系统要执行的任务相对单一，程序一般是固化在硬件里。当然这时使用冯·诺依曼结构也完全可以，代码区和数据区在编译时一次性分配好了而已，但是其灵活性得不到体现，所以现在大量的单片机也还在沿用冯·诺依曼结构，如TI的MSP430系列、Freescale的HCS08系列等。 那是为什么说哈佛结构有优势呢？嵌入式计算机在工作时与通用计算机有着一些区别：嵌入式计算机在工作期间的绝大部分时间是无人值守的，而通用计算机工作期间一般是有人操作的；嵌入式计算机的故障可能会导致灾难性的后果，而通用计算机一般就是死死机，重新启动即可。这两点决定了对嵌入式计算机的一个基本要求：可靠性。 使用冯·诺依曼结构的计算机，程序空间不封闭，期程序空间的数据在运行期理论上可以被修改，此外程序一旦跑飞也有可能运行到数据区。虽然都是一些不常见的特殊情况下，但是看看哈佛结构德计算机在这些情况下是怎样的：基于哈佛结构的处理器入MCS-51，不需要可以对代码段进行写操作的指令，所以不会有代码区被改写的问题；程序只能在封闭的代码区中运行，不可能跑到数据区，这也是跑飞的几率减少并且跑飞后的行为有规律（数据区的数据是不断变化的而代码区是不变的）。 所以，相对于冯·诺依曼结构，哈佛结构更加适合于那些程序固化、任务相对简单的控制系统。 总结冯.诺依曼结构：程序只是一种（特殊）的数据，它可以像数据一样被处理，因此可以和数据一起被存储在同一个存储器中——这就是著名的冯.诺依曼原理。注意:数据总线和地址总线共用。 哈佛结构:一种并行体系结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。与两个存储器相对应的是系统的4条总线：程序的数据总线与地址总线，数据的数据总线与地址总线。这种分离的程序总线和数据总线允许在一个机器周期内同时获得指令字（来自程序存储器）和操作数（来自数据存储器），从而提高了执行速度，使数据的吞吐率提高了1倍。又由于程序和数据存储器在两个分开的物理空间中，因此取指和执行能完全重叠。CPU首先到程序指令存储器中读取程序指令内解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。","categories":[{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"http://yoursite.com/categories/计算机体系结构/"}],"tags":[{"name":"体系结构","slug":"体系结构","permalink":"http://yoursite.com/tags/体系结构/"}]}]}